# 第三章：排序

### 依照顺序排列

* 在解决问题前，要首先找到关键点精确定义问题，然后是找出高效求解算法。如袜子配对问题，若只是颜色一样即可，（在不区分左右前提下）只买一种颜色样式的就行，这样随便找出两只就可以，O(1)时间；但若精确到一双的概念，则需要买不同颜色的，以基数排序方法解决，O(n+n*log(n/m))时间。尽量避免基于直接比较的O(n^2)算法。

**策略**：东西越多越难搞，所以要减少处理对象的数量。

* 基数排序是愈高位愈放在靠后的循环中处理。

* 桶排序需要尽量将数据均匀分散至尽量多的桶中，使得后续处理时桶内部的比较操作尽可能少，从而达到最优效率。

* 合并排序广受采用，且适于并行化，即树的每一层中每两个有序子集的合并可并行分配至多台机器上同时完成，从而树状图中每一层（由顶至底）的运行时间（比较次数）为n、n/2、n/4...（每一层的节点都是在并行处理，只算一个的值），故执行时间是2n=O(n)。

**结论**：排序的唯一价值就是**辅助以后搜索**，如果搜索不难，就宁乱勿整。

### 名次未必反映实力-运动赛事里的演算法

* 当前大多赛事只能决出第一名，却不能真正确定第二名及以后的名次排位。

### 排序效率差的价值-稳固

* 足球比赛的比分越低，比赛结果越随机，越对弱队有利。

* 合并排序高效但脆弱，一旦大意就会对结果产生很大影响。而冒泡排序虽慢，但抗干扰稳定性好。

* 比较计数排序（Comparison Counting Sort）是目前已知**最稳固**的排序算法。

### 血腥排序：啄序和优势阶级

* 动物运用**阶级**知识，判断不值得对抗时就会出现替代行为。如资源较少时该由谁拥有。事先建立顺序会比临时打架要温和多，也更易于管理。

* 啄序被认为是防范暴力的暴力手段，是群体自动完成的。故每个个体在明确在群体中的阶级，才能减少打斗次数，否则暴力会不断出现。

### 以竞赛取代打斗

* 以**排名**的序数改为基数（基准），就能自然依序排列，避免比较（打斗），很快决定排名，从而突破基于比较排序的O(n*log^n)下界（如基数排序）。

* 以竞赛取代打斗。
